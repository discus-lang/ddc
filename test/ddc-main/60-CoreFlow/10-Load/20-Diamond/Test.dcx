
:set lang Flow

-- Kernel of QuickHull algorithm.
-- This has a diamond dependency on the points stream,
--  which is something that generic stream fusion can't fuse.
:load..
module Test with letrec


-- Get the maximum of two floats.
max     (n1 : Float64#) (n2 : Float64#) : Float64#
 = case gt# [Float64#] n1 n2 of
        True#   -> n1
        False#  -> n2


-- Compute the determinate between a line and a point vector.
det     (l1 : Tuple2# Float64# Float64#)
        (l2 : Tuple2# Float64# Float64#)
        (p0 : Tuple2# Float64# Float64#) 
        : Float64#
 = case p0 of { T2# x0 y0 -> 
   case l1 of { T2# x1 y1 -> 
   case l2 of { T2# x2 y2 -> 
        sub# [Float64#]
                (mul# [Float64#] 
                        (sub# [Float64#] x1 x0) 
                        (sub# [Float64#] y2 y0))
                (mul# [Float64#]
                        (sub# [Float64#] y1 y0)
                        (sub# [Float64#] x2 x0)) }}}


-- Select points that are above the given line,
--  and also return the maximum determinate.
split   [k1      : Rate]
        (l1      : Tuple2# Float64# Float64#)
        (l2      : Tuple2# Float64# Float64#)
        (points  : Series# k1 (Tuple2# Float64# Float64#))
        (vec     : Vector# (Tuple2# Float64# Float64#))
        (mx      : Ref# Float64#)
        : Process#
 = do
        -- Take the determinate between the line and each point.
        dets    
         = smap# [k1] [Tuple2# Float64# Float64#] [Float64#]
                (det l1 l2) 
                points

        -- We only want points where the determinate is more than zero.
        flags   
         = smap# [k1] [Float64#] [Bool#]
                (gt# [Float64#] (promote# [Float64#] [Nat#] 0#)) 
                dets

        pjoin#  -- Filter the points, keeping those where the determinate was more
                -- than zero.
                (smkSel1# [k1] flags 
                 (/\(k2 : Rate). \(sel : Sel1# k1 k2).
                 let above   = spack# [k1] [k2] [Tuple2# Float64# Float64#] sel points 
                 in  sfill# [k2] [Tuple2# Float64# Float64#] vec above))

                -- Also compute the maximum determinate.
                (sreduce# [k1] [Float64#] mx max
                        (promote# [Float64#] [Nat#] 0#)
                        dets)
;;
